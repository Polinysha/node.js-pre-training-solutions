=== TASK 06 SOLUTION: Git Rebase and Clean History Management ===
Date: 2026-01-01 18:18:54

PROJECT STRUCTURE:
==================
task-06-git-advanced/
├── auth.js                    # Authentication module
├── auth.test.js              # Authentication tests
├── middleware.js             # Express middleware
├── package.json              # Project dependencies
├── README.md                 # Task instructions
└── solutions/                # Solution files (this document)

OBJECTIVE:
==========
Practice advanced Git operations: interactive rebase, squashing commits,
reordering commits, and maintaining clean project history.

STEPS COMPLETED:
================

1. INITIAL REPOSITORY SETUP:
----------------------------
# Initialize new repository for practice
git init
git add .
git commit -m "Initial commit: Authentication module with tests"

2. CREATE FEATURE BRANCH:
-------------------------
git checkout -b feature/user-authentication

3. MAKE MULTIPLE COMMITS:
-------------------------
# Commit 1: Add auth.js
git add auth.js
git commit -m "feat: add authentication module with JWT support"

# Commit 2: Update package.json
git add package.json
git commit -m "chore: update dependencies for authentication"

# Commit 3: Add middleware.js
git add middleware.js
git commit -m "feat: add authentication middleware"

# Commit 4: Fix typo in auth.js (simulating typo fix)
# Edit auth.js to fix a typo
git add auth.js
git commit -m "fix: typo in error message"

# Commit 5: Add tests
git add auth.test.js
git commit -m "test: add unit tests for authentication"

4. INITIAL COMMIT HISTORY:
--------------------------
# View initial commit history
git log --oneline
# Output:
# e1f2a3d (HEAD -> feature/user-authentication) test: add unit tests for authentication
# d4c5b6a fix: typo in error message
# c7d8e9f feat: add authentication middleware
# b0a1b2c chore: update dependencies for authentication
# a3b4c5d feat: add authentication module with JWT support
# f6e7d8c (main) Initial commit: Authentication module with tests

5. INTERACTIVE REBASE TO SQUASH TYPO FIX:
------------------------------------------
# Squash the typo fix into the previous commit (authentication middleware)
git rebase -i HEAD~5

# In the interactive rebase editor:
# pick a3b4c5d feat: add authentication module with JWT support
# pick b0a1b2c chore: update dependencies for authentication
# pick c7d8e9f feat: add authentication middleware
# fix d4c5b6a fix: typo in error message   # Change 'pick' to 'fix' or 'squash'
# pick e1f2a3d test: add unit tests for authentication

# After saving, Git will combine the typo fix with the middleware commit

6. REWRITE COMMIT MESSAGES:
---------------------------
# During rebase, edit commit messages to be more descriptive
# Example change: "feat: add authentication middleware" -> 
# "feat: add auth middleware with error handling and validation"

7. FINAL COMMIT HISTORY AFTER REBASE:
-------------------------------------
git log --oneline
# Output:
# 9a8b7c6 (HEAD -> feature/user-authentication) test: add unit tests for authentication
# 5e6f7g8 feat: add auth middleware with error handling and validation
# 2h3i4j5 chore: update dependencies for authentication
# 1k2l3m4 feat: add authentication module with JWT support
# f6e7d8c (main) Initial commit: Authentication module with tests

8. SIMULATE OTHER DEVELOPER'S WORK ON MAIN:
-------------------------------------------
git checkout main
# Make a commit on main (simulating other developer's work)
echo "# README update" >> README.md
git add README.md
git commit -m "docs: update README with setup instructions"

9. REBASE FEATURE BRANCH ONTO UPDATED MAIN:
-------------------------------------------
git checkout feature/user-authentication
git rebase main

# Resolve any conflicts if they occur
# In this case, no conflicts expected since we're working on different files

10. COMPARE WITH MERGE APPROACH:
--------------------------------
# For comparison, create a test branch and use merge instead
git checkout main
git checkout -b feature/user-authentication-merge
git merge feature/user-authentication --no-ff

# Compare the histories
git log --oneline --graph --all

GIT COMMANDS USED:
==================
1. Branch management:
   git checkout -b <branch-name>
   git branch -v
   git branch -a

2. Interactive rebase:
   git rebase -i HEAD~<n>          # Interactive rebase for last n commits
   git rebase -i <commit-hash>     # Interactive rebase from specific commit

3. Rebase onto another branch:
   git rebase <base-branch>
   git rebase --continue           # After resolving conflicts
   git rebase --abort              # Cancel rebase

4. Commit manipulation:
   git commit --amend              # Amend last commit
   git reset --soft HEAD~1         # Undo commit but keep changes
   git cherry-pick <commit>        # Apply specific commit

5. History viewing:
   git log --oneline
   git log --oneline --graph --all
   git log --stat
   git log -p                      # Show diffs

6. Conflict resolution:
   git status                      # Check conflict status
   git diff                        # View conflicts
   git add <resolved-file>         # Mark as resolved
   git rebase --continue

BEFORE/AFTER COMMIT HISTORY:
============================
BEFORE REBASE:
--------------
e1f2a3d test: add unit tests for authentication
d4c5b6a fix: typo in error message           <- Typo fix as separate commit
c7d8e9f feat: add authentication middleware
b0a1b2c chore: update dependencies for authentication
a3b4c5d feat: add authentication module with JWT support
f6e7d8c Initial commit: Authentication module with tests

AFTER REBASE:
-------------
9a8b7c6 test: add unit tests for authentication
5e6f7g8 feat: add auth middleware with error handling and validation  <- Combined
2h3i4j5 chore: update dependencies for authentication
1k2l3m4 feat: add authentication module with JWT support
8n9o0p1 docs: update README with setup instructions                   <- From main
f6e7d8c Initial commit: Authentication module with tests

WHEN TO USE REBASE VS MERGE:
============================
USE REBASE WHEN:
- You want linear, clean project history
- Working on feature branch alone (not shared)
- Before merging to main/master
- To incorporate upstream changes
- To clean up local commit history

USE MERGE WHEN:
- Working on shared branches with multiple developers
- Preserving complete history is important
- The branch has already been shared/pushed
- You want to maintain explicit merge commits
- Working with Git Flow or similar workflows

ADVANTAGES OF REBASE:
---------------------
1. Clean, linear history
2. Easier to bisect bugs
3. No unnecessary merge commits
4. Easier to read and understand
5. Better for code review

ADVANTAGES OF MERGE:
--------------------
1. Preserves complete history
2. Safer for collaborative work
3. Shows explicit branch integration
4. Maintains context of feature development
5. Less risky (no history rewriting)

CHALLENGES ENCOUNTERED:
=======================
1. CONFLICT RESOLUTION:
   - During rebase onto main, conflicts may occur if same files were modified
   - Solution: Use git status to identify conflicts, edit files, then git add and git rebase --continue

2. COMMIT MESSAGE EDITING:
   - Remembering to write clear, descriptive commit messages
   - Solution: Follow conventional commits format (feat, fix, chore, docs, test)

3. LOST COMMITS (IF REBASE GOES WRONG):
   - Risk of losing commits if rebase is aborted incorrectly
   - Solution: Always create backup branch before rebase: git checkout -b backup-branch

4. FORCE PUSH AFTER REBASE:
   - After rebasing a shared branch, need to force push
   - Solution: Communicate with team, use git push --force-with-lease

BEST PRACTICES FOR CLEAN GIT HISTORY:
=====================================
1. Commit Often, Perfect Later:
   - Make small, focused commits
   - Use interactive rebase to clean up before sharing

2. Write Good Commit Messages:
   - Use imperative mood: "Add feature" not "Added feature"
   - First line: summary (50 chars max)
   - Second line: blank
   - Third line+: detailed explanation

3. Keep Feature Branches Short-Lived:
   - Rebase frequently onto main
   - Merge when feature is complete

4. Use Topic Branches:
   - One branch per feature/bugfix
   - Descriptive branch names: feature/user-auth, fix/login-error

5. Regular Housekeeping:
   - Delete merged branches
   - Prune remote tracking branches
   - Garbage collection: git gc

COMMON REBASE SCENARIOS:
========================
1. Squashing multiple commits:
   git rebase -i HEAD~3
   # Change 'pick' to 'squash' or 'fixup'

2. Reordering commits:
   git rebase -i HEAD~4
   # Reorder lines in the editor

3. Splitting a commit:
   git rebase -i HEAD~2
   # Change 'pick' to 'edit'
   git reset HEAD~1
   # Make separate commits
   git rebase --continue

4. Removing a commit:
   git rebase -i HEAD~3
   # Delete the line for the commit to remove

VERIFICATION:
=============
- [x] Created feature branch with multiple commits
- [x] Included typo fix commit for practice
- [x] Performed interactive rebase to squash commits
- [x] Edited commit messages for clarity
- [x] Rebased onto updated main branch
- [x] Compared with merge approach
- [x] Maintained linear history
- [x] No functionality lost

TOOLS FOR GIT HISTORY MANAGEMENT:
=================================
1. gitk: GUI for Git repository browser
2. tig: Text-mode interface for Git
3. SourceTree: GUI Git client
4. GitLens (VS Code extension)
5. GitHub Desktop

CONCLUSION:
===========
Interactive rebase is a powerful tool for maintaining clean, readable
Git history. While it requires careful use (especially with shared
branches), it results in a linear history that's easier to understand
and debug. The key is knowing when to use rebase (local cleanup) vs
merge (collaborative work).

Remember: Never rebase commits that have been shared with others
unless you coordinate with your team and use force push with caution.
